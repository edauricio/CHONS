CHANGE ELEMENTFACTORY CLASS IN TWO WAYS
ONE-
Implement it in a two-step interface.
First, MeshReader should read all elements and proceed exactly as done right now, that is,
communicating every new element to ElementFactory.
However, ElementFactory should not allocate memory for the elements right away.
As learned when reading Boost.Pool, this causes a drastic memory overhead, because for each
new operator the program calls for a chunck of memory from the pool, which the OS memory manager
also uses to save some information on it (for example the size of the chunk, in order to correctly
delete (free) it later when called to do so). Hence, for every new operation on a single element
we are actually losing some memory to the OS memory manager.
It is then wiser and way more efficient to first gather all the info about the elements in a data
structure and only then allocate them using new operations. In this manner, not only we avoid the memory
overhead of calling new on every tiny element, but we also make it way more cache-friendly
since they will be all (or at least dimension-wise) in the same chunk of memory (remember that
we will need to access them later, a LOT of times actually).
In order to actually allocate memory, the class should have a AllocateAll() interface or something
similar.
(After making this change we will probably be able to read the 2M element hexa mesh in laptop)

----
After making the changes above with standard allocators (no specific allocators for STL containers
and also using raw new operations to allocate elements), try Boost.Pool allocators to see if
there is any improvement both in time (remember: dynamic memory allocation/deallocation is an
expensive operation in terms of CPU cost) and memory usage.
----


TWO-
The ElementFactory class checks if an element already exists by calling find()
on a map, that maps each ElementType to another map containing the element's tag and
a pointer to it. If the ElementType-Tag pair doesn't match the one asked, the element
doesn't exists and so it is created; otherwise, returns the pointer to the element.
However, maybe this first find() on the map of ElementType value_key may be improved
by turning this map into a vector, because in fact tags are not numbered according
to ElementType, but element dimension. Hence, nodes, lines, 2D and 3D elements will
be uniquely tagged, respectively. Since the access for a vector is faster than a 
find(), this might decrease ElementFactory check time.
Of course, if-else statements will be needed in order to know which vector element
to look for (or maybe "map" somehow ElementType to the corresponding vector entry).

=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-==-=-=-=-=

CREATE RESOURCE DIRECTOR CLASS
A Resource Director class should be created to manage all resource requests
These resources include but are not limited to:
- Memory (duh!)
- Threads
A previous analysis/design should be made in order to define its interface
and responsibilities.

=-=-=--=-=-=-=--=--=--=-=-=-=-=-=-=-=-=-=--=--=--=-

ANALYSIS/DESIGN OF CLASS TO HANDLE MESH CREATION/GRAPH ADDITIOn
This class should be responsible for adding the appropriated information to
the MeshGraph (or MeshInfoHandler) class.

=-=-==-=-=--==-=-==-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-

(USE BOOST/SIMPLE ONE INSTEAD) 
Assert class to throw a (handling) exception and put a message to std:cerr
  instead of checking errors with if statements and hard-coded exiting the program.

-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=--=--=-=-=-=---=-

2) ADJACENCY:
The MeshGraph should contain a list of Element adjacencies (check if this is really necessary)
relating Element-to-Element and also ElementFace-to-ElementFace. In order to compute the nume-
rical flux (e.g., to solve a Riemann problem), one element only asks MeshGraph the element
adjacent to the face of interest. For this to happen, both the requesting element must know
his face tag, and the MeshGraph object must have the the elements that share such face, so that
it returns the element other than the requesting element. When it's a boundary, MeshGraph also
have this info and return according to the set boundary condition.
ALTERNATIVELY:
Just make a request for each one of the element's primitives for its Sharing elements so that
the one we're looking for is the one other than the current working element.
Boundary data handling still needs a way to be handled in this way.
IN ANY CASE:
A MeshGraph object may not be a must, but it is certainly useful and probably wise to have one
so that we concentrate every mesh-related requests in one object. For example, the driver
will need boundary NAME info when setting the boundary conditions for every iteration. Right now,
the only object having it is MeshReader, which will soon be destroyed (b4 the boundary cond.
can be applied). Hence, this info must be passed along to the MeshGraph.

=--=-=--=-=--=-=-=--=-=-=-=-

CREATE A "NATIVE" MESH FILE FORMAT
It is important to have a "native" file format for two reasons
one) It will speed up a lot the prepocessing if we could read the mesh faster. By reading a
"raw" (msh/cgns) mesh file and writing it down in a "native" format, we could make this
native format very straightforward to read in the way our software is architected. For example,
we could put all the nodes, then all the edges, then all 2D faces, then all 3D elements line
by line so that we would basically just use getline() and ask the factory to create our element.

two) Imagine that our mesh is very, very big, say 500.000.000 (500mil) elements. This amount of
infomartion probably won't fit even in a 64Gb memory, so obviously the mesh would need to be
READ separately, i.e. directly in each processes' memory. We could then read the "raw" (msh/cgns)
mesh file and, according to an option passed about how many processes are going to be used,
write our "native" mesh file already partitioned (using metis to do so).
In other words, the input mesh file would be either in serial or parallel format.

To create this native mesh file, a tool would be used (and MeshModule could definitely be reused
here, probably with another implementation on the Section bridge), either a new executable or
a parameter like -import should be passed to the main program.
