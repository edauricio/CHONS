ADD NEW STATE VARIABLE FOR EACH ELEMENT
In order to be able to treat element's primitives correctly, a new variable should be
added for each element so we know how many primitives define the "incomplete" (no interior
nodes) object. For eaxmple, for a Quad, this should be something like s_incPrims=4. Since 
we lost the information on primitive type by substituting the map for a simple vector, in
this way we are still capable of knowing which primitives really define the element, 
e.g. the edges, and which are the interior, e.g. face, nodes. Of course, for that to work, 
we rely on the precondition that the primitives are added in such order.

=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-

ANALYSIS/DESIGN THE "GRAPHING STRUCTURE" OF OUR MESH
That is, the class/object that will interact directly (and VERY FREQUENTLY) with the solver
in order to give it the needed adjacency information. Hence, because of the high frequency,
the implementation should be as fast as possible.
After this "permament" data structure is done setting, we can free most of the memory used
for the intermediary data structures (the ones used to actually gather the adjacency information)
using the ResourceDirector class (below)

=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-==-=-=-=-=

CREATE RESOURCE DIRECTOR CLASS
A Resource Director class should be created to manage all resource requests
These resources include but are not limited to:
- Memory (duh!)
- Threads
A previous analysis/design should be made in order to define its interface
and responsibilities.

=-=-=--=-=-=-=--=--=--=-=-=-=-=-=-=-=-=-=--=--=--=-

2) ADJACENCY:
The MeshGraph should contain a list of Element adjacencies (check if this is really necessary)
relating Element-to-Element and also ElementFace-to-ElementFace. In order to compute the nume-
rical flux (e.g., to solve a Riemann problem), one element only asks MeshGraph the element
adjacent to the face of interest. For this to happen, both the requesting element must know
his face tag, and the MeshGraph object must have the the elements that share such face, so that
it returns the element other than the requesting element. When it's a boundary, MeshGraph also
have this info and return according to the set boundary condition.
ALTERNATIVELY:
Just make a request for each one of the element's primitives for its Sharing elements so that
the one we're looking for is the one other than the current working element.
Boundary data handling still needs a way to be handled in this way.
IN ANY CASE:
A MeshGraph object may not be a must, but it is certainly useful and probably wise to have one
so that we concentrate every mesh-related requests in one object. For example, the driver
will need boundary NAME info when setting the boundary conditions for every iteration. Right now,
the only object having it is MeshReader, which will soon be destroyed (b4 the boundary cond.
can be applied). Hence, this info must be passed along to the MeshGraph.

=--=-=--=-=--=-=-=--=-=-=-=-

CREATE A "NATIVE" MESH FILE FORMAT
It is important to have a "native" file format for two reasons
one) It will speed up a lot the prepocessing if we could read the mesh faster. By reading a
"raw" (msh/cgns) mesh file and writing it down in a "native" format, we could make this
native format very straightforward to read in the way our software is architected. For example,
we could put all the nodes, then all the edges, then all 2D faces, then all 3D elements line
by line so that we would basically just use getline() and ask the factory to create our element.

two) Imagine that our mesh is very, very big, say 500.000.000 (500mil) elements. This amount of
infomartion probably won't fit even in a 64Gb memory, so obviously the mesh would need to be
READ separately, i.e. directly in each processes' memory. We could then read the "raw" (msh/cgns)
mesh file and, according to an option passed about how many processes are going to be used,
write our "native" mesh file already partitioned (using metis to do so).
In other words, the input mesh file would be either in serial or parallel format.

To create this native mesh file, a tool would be used (and MeshModule could definitely be reused
here, probably with another implementation on the Section bridge), either a new executable or
a parameter like -import should be passed to the main program.
